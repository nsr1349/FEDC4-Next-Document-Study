## error handle

error.js에선 예기치 않은 런타임 오류를 우아하게 처리 가능하다.

- 자동적으로 라우트 세그먼트와 해당 중첩된 자식요소를 React Error Boundary 로 래핑합니다
- 파일 시스템 계층 구조를 사용하여, 특정 세그먼트에 알맞게 조정된 오류 ui를 생성해줍니다.
- 나머지 애플리케이션들은 작동하는 상태로, 에러가 난 세그먼트에 대한 오류만 격리합니다.
- 전체 페이지 새로고침 없이, 오류 복구를 시도하는 reset 함수를 제공합니다.



감시할 page.js 파일과 같은 세그먼트에 error.js를 만드는 것이 기본적인 사용 방법입니다.
![image](https://github.com/nsr1349/FEDC4-Next-Document-Study/assets/79898508/17c4538c-b48d-4d03-876f-d495afbdbcea)


error.js파일 양식 예시입니다.
```
'use client' // Error components must be Client Components
 
import { useEffect } from 'react'
 
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])
 
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  )
}
```

1. error.js는 반드시 클라이언트 컴포넌트여야만 합니다.
2. 파라미터의 error는 구체적인 에러메세지가 들어있습니다. 필요에 따라 console 등에 출력해보세요
3. 파라미터의 reset 이라는 함수는 실행시 오류가 난 페이지의 재렌더링을 시도합니다.
4. 에러가 나서 빈 페이지를 채울 dom 내용을 return 해 주시면 됩니다.



#### 작동방식

![image](https://github.com/nsr1349/FEDC4-Next-Document-Study/assets/79898508/41fcc550-546f-4f16-a89a-7e67c20ff751)

error.js는 React Error Boundary 를 자동적으로 생성합니다.
React Error Boundary는 해당, 그리고 하위 세그먼트를 래핑합니다.
래핑요소 중, 오류 발생시, 해당요소를 error.js 의 dom 요소로 대체된다고 보면 됩니다.
대체된 dom 요소는 오류 경계 위의 레이아웃을 유지하며, 유저와 상호작용이 가능한 형태로 렌더링됩니다. 오류 구성요소에는 오류를 복구하는 기능이 표시될 수도 있습니다.



#### 오류복구

reset() 함수가 바로 그것입니다. 에러는 일시적일 수 있기에, 함수를 사용하면 오류가 난 페이지의 복구를 재시도합니다. 성공한다면 대체 오류 구성요소는 사라지고, 다시 원래의 렌더링 결과로 대체됩니다.

```
'use client'
 
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```



#### 중첩된 경로

특수파일(special files) 를 통해 생성된 react 구성요소는 특정 중첩 계층구조(specific nested hierarchy) 로 렌더링 됩니다. (이 문장의 한글 번역은 정확하지 않을 수 있습니다.)

예시로 왼쪽과 같이 파일 구조를 만들 경우, 오른쪽과 같은 구조로 구성요소가 이루어 집니다.
![image](https://github.com/nsr1349/FEDC4-Next-Document-Study/assets/79898508/0f135183-3c3d-4af0-bd55-7605377964ce)

중첩된 컴포넌트 계층 구조는 중첩된 라우트에서 error.js 파일의 동작에 영향을 미칩니다.
오류는 가장 가까운 부모 오류 바운더리로 버블링됩니다. 이것은 error.js 파일이 해당 중첩된 자식 세그먼트의 모든 오류를 처리할 것을 의미합니다. 
더욱 세분화 하여 error.js 파일을 만들수록, 세분화된 에러처리를 할 수도 있겠군요?

또한 동일한 세그먼트 내의 layout.js 의 에러는, 오류 처리를 하지 않습니다.
위의 사진구조와 같이 layout.js 는 에러 바운더리 하위요소가 아니기 때문에 감지할 수 없다고 보시면 됩니다.



#### layout.js 에러 핸들링 하는 법?
핵심만 짚자면, 그냥 더 상위 세그먼트에 error.js 파일을 만들면 됩니다.
만약, 에러핸들을 하고 싶은 layout.js 가 루트에 있는 경우라면, global-error.js 라는 별개의 파일로 핸들링하시기 바랍니다.

```
'use client'
 
export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  )
}
```





